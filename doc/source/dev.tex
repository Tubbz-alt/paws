\chapter{development}
\label{ch:dev}

This chapter covers some best practices 
for contributing to \verb|paws| via git (section~\ref{sec:paws_dev})
and instructions for developing operations
for use in the \verb|paws| workflow engine (section~\ref{sec:op_dev}).
These instructions are intended for people
who are familiar with the \verb|paws| development team
and have received an invitation to work in their private repository.


\section{contributing to paws}
\label{sec:paws_dev}

The \verb|paws| repository is currently private.
Request access by getting in touch with the \verb|paws| developers
at \verb|paws-developers@slac.stanford.edu|. 
You can also join the paws-developers listserv.
Send an email to 
\begin{lstlisting}
listserv@listserv.slac.stanford.edu
\end{lstlisting}
with no subject and the following text in the body: 
\begin{lstlisting}
SUB PAWS-DEVELOPERS
\end{lstlisting}
If you want to unsubscribe, use:
\begin{lstlisting}
UNSUB PAWS-DEVELOPERS
\end{lstlisting}
If you need to configure your list settings, 
look up the latest ListServ documentation.

Code development is currently following the ``shared repository model'',
meaning developers have write access to the main repository.
All contributed code should be written in feature branches.
The \verb|master| and \verb|dev| branches are protected,
such that they can only be contributed to via pull requests
or by contacting the development team.

The \verb|master| branch is intended to be the most stable tested version,
and the \verb|dev| branch is for staging features that have been developed.
The rest of the branches should contain features being actively developed.
Once you have access, clone the repository
and create your own development or feature branch.
When you are satisfied, make sure your feature branch 
includes the latest changes to \verb|dev|
(either merge \verb|dev| into your branch, 
or rebase your branch on \verb|dev|),
and then submit a pull request to initiate 
a review that will ultimately merge your feature branch with \verb|dev|.


%\textbf{--- start here the first time you work on paws ---} 
%\begin{enumerate} 
%    \item Get in touch with the paws developers to get access to the repository. 
%        See ~\ref{sec:introduction}.
%    \item Clone the repository: 
%    \begin{itemize} 
%        \item CL: \verb|git clone <REPO-URL>|. 
%        \item \verb|PyCharm|: VCS > Checkout from Version Control > enter repository URL
%    \end{itemize} 
%    This copies the remote repository (hosted online)
%    to a local directory (on your machine). 
%    Your new directory contains the source code
%    and a local \verb|master| branch 
%    that tracks the remote \verb|master| branch.
%    \item Create a \verb|dev| branch that tracks the origin's \verb|dev| branch.
%    \begin{itemize} 
%        \item CL: \verb|git checkout -b dev origin/dev|. 
%        %\verb|git checkout dev|, 
%        %which is implied shorthand for
%        %\verb|git checkout --track origin/dev|, which is shorthand for
%        \item \verb|PyCharm|: VCS > Git > Branches, select origin/dev, Checkout as new local branch 
%    \end{itemize} 
%    \item Create your own feature branch. 
%    \label{itm:init_laststep}
%    \begin{itemize} 
%        \item CL: \verb|git branch my-feature-branch| 
%        \item \verb|PyCharm|: VCS > Git > Branches, New branch
%    \end{itemize} 
%%\end{enumerate} 
%    \item \textbf{--- start here every time you work on your feature ---}
%%\begin{enumerate}
%    %\item Ensure there are no unstaged changes lying around.
%    %\begin{itemize} 
%    %    \item CL: \verb|git status|
%    %    \item \verb|PyCharm|:  
%    %\end{itemize} 
%    %If you have made changes, \verb|git| will track them,
%    %throw errors in the next steps.
%    %Either commit the changes to your feature branch,
%    %or get rid of them. To get rid of them:
%    %\begin{itemize} 
%    %    \item CL: first run \verb|git stash|, then \verb|git stash drop|
%    %    \item \verb|PyCharm|:  
%    %\end{itemize} 
%    \item Check out the \verb|dev| branch.
%    \label{itm:rebase_start}
%    \begin{itemize} 
%        \item CL: \verb|git checkout dev|
%        \item \verb|PyCharm|: VCS > Git > Branches, dev -> origin/dev, Checkout 
%    \end{itemize} 
%    \item Pull the latest commits from the remote \verb|dev| branch.
%    \begin{itemize} 
%        \item CL: \verb|git pull origin dev|
%        \item \verb|PyCharm|: VCS > Git > Pull Changes 
%    \end{itemize} 
%    \item Check out your feature branch.
%    \begin{itemize} 
%        \item CL: \verb|git checkout my-feature-branch|
%        \item \verb|PyCharm|: VCS > Git > Branches, <yourFeatureBranch>, Checkout 
%    \end{itemize} 
%    \item Rebase your feature branch onto the \verb|dev| branch. 
%    \label{itm:rebase_end}
%    \begin{itemize} 
%        \item CL: \verb|git rebase dev| 
%        \item \verb|PyCharm|: VCS > Git > Rebase
%    \end{itemize} 
%    If you have conflicts during the rebase, 
%    due to changes in \verb|dev| that disagree with changes in your feature,
%    this step can be skipped for the moment,
%    but these conflicts will eventually need to be cleaned up.
%    Get help from a fellow developer, 
%    or if you are pretty sure your version of the code is better,
%    try a pull request!
%    \item Finally, \textbf{work on your feature}. 
%    \item After working, make sure you are still on your feature branch, 
%    then stage your edits. 
%    \begin{itemize} 
%        \item CL: \verb|git add .| 
%        \item \verb|PyCharm|: skip this step 
%    \end{itemize} 
%    \item After staging your edits, commit them with a description. 
%    \label{itm:commitfeature} 
%    \begin{itemize} 
%        \item CL: \verb|git commit -m 'description of edits'| 
%        \item \verb|PyCharm|: VCS > Commit Changes
%    \end{itemize} 
%    \item Push your commits on your feature branch to the origin (remote) repository.
%    \label{itm:pushfeature} 
%    \begin{itemize} 
%        \item CL: \verb|git push origin my-feature-branch| 
%        \item \verb|PyCharm|: VCS > Git > Push 
%    \end{itemize} 
%    Now your colleagues can see what you have done,
%    and use your changes in their own code if they need to!
%%\end{enumerate} 
%    \item \textbf{--- start here when you are done with your feature ---}
%%\begin{enumerate}
%    \item Follow steps~\ref{itm:rebase_start} through~\ref{itm:rebase_end} above
%    to rebase your feature branch on \verb|dev| one last time.
%    %\item If the rebase changed anything, 
%    %use step~\ref{itm:pushfeature} 
%    %above for one last push to the remote repo.
%    \item If you know that your changes 
%    are not likely to crash your co-workers' codes 
%    when they are merged to the \verb|dev| branch, 
%    you can now merge your feature into the \verb|dev| branch
%    and push \verb|dev| to the remote repository.
%    \begin{itemize} 
%        \item CL: 
%        %\verb|git checkout dev|, 
%        %then \verb|git merge my-feature-branch|, 
%        %then \verb|git push origin dev|.
%        \begin{lstlisting}
%            git checkout dev 
%            git merge my-feature-branch 
%            % mildly cautious reflection 
%            git push origin dev
%        \end{lstlisting}
%        \item \verb|PyCharm|:  
%        \begin{itemize} 
%            \item VCS > Git > Branches, dev -> origin/dev, Checkout 
%            \item VCS > Git > Branches, <yourFeatureBranch>, Merge 
%            \item mildly cautious reflection
%            \item VCS > Git > Push 
%        \end{itemize} 
%    \end{itemize} 
%    \item If you aren't 100\% sure that it's safe to merge your feature into \verb|dev|,
%    submit a pull request via the online interface.
%    Request to pull \verb|my-feature-branch| into \verb|dev|.
%    The \verb|paws| development team will discuss, possibly edit, 
%    and ultimately accept your feature.
%    \item If your feature was more appropriate for the \verb|master| branch,
%    submit a pull request for the \verb|master| branch.
%\end{enumerate} 

\section{developing operations for paws}
\label{sec:op_dev}

Developing operations for use in the \verb|paws| workflow engine 
is meant to be as painless as possible.
A continuing effort will be made to streamline this process.

The most general description of an operation 
is to treat it as a black box that takes some inputs 
(data, parameters, references to plugin objects),
performs some processing with those inputs,
and produces some output (data and other features).

\verb|paws| Operations are implemented 
by subclassing a Python abstract base class.
An Operation defines names for its inputs and outputs,
documentation for each input and output,
and a run() method that creates outputs from the specified inputs.
This process is most easily understood 
by following the template in section~\ref{sec:template} below.

\subsection{operation template}
\label{sec:template}

The following code block gives a minimal, 
commented template for developing
Operations as python classes.
Users/developers with some programming background
may find all the information they need in this template alone.

\lstset{language=Python}
\begin{lstlisting}
from operation import Operation
import optools

# Replace <OperationName> with a SHORT operation title 
class <OperationName>(Operation):
    # Replace <Description of Operation> with a detailed description 
    """<Description of Operation>"""

    def __init__(self):
        """<Description of anything notable performed during __init__()>"""
        # Name the inputs and outputs for your operation.
        input_names = ['<input_name_1>','<input_name_2>',<...>]
        output_names = ['<output_name_1>','<output_name_2>',<...>]
        # Replace <OperationName> with the same name chosen above
        super(<OperationName>,self).__init__(input_names,output_names)
        # Provide a basic description for each of the inputs and outputs 
        self.input_doc['<input_name_1>'] = '<expectations for input 1>'
        self.input_doc['<input_name_2>'] = '<etc>'
        self.output_doc['<output_name_1>'] = '<description of output 1>'
        self.output_doc['<output_name_2>'] = '<etc>'
        # OPTIONAL: set default sources, types, values for the inputs.
        # Valid sources:
        #   optools.no_input (default input to None), 
        #   optools.wf_input (take input from another operation in the workflow), 
        #   optools.text_input (manual text input)
        #   optools.plugin_input (take input from a PawsPlugin)
        #   optools.batch_input (input provided by a batch/realtime operation)
        self.input_src['<input_name_1>'] = <optools.some_source>
        self.input_src['<input_name_2>'] = <etc>
        # Valid types: optools.none_type (None), optools.str_type (string), 
        #   optools.int_type (integer), optools.float_type (float), 
        #   optools.bool_type (boolean), optools.ref_type (direct reference),
        #   optools.path_type (a path to something in the filesystem or workflow), 
        #   optools.auto_type (default for chosen source, or input set by batch)
        self.input_type['<input_name_1>'] = <optools.some_type>
        self.input_type['<input_name_2>'] = <etc>
        
    # Write a run() function for this Operation.
    def run(self):
        """<Description of processing performed by run()>"""
        # Optional- create references in the local namespace for cleaner code.
        <inp1> = self.inputs['<input_name_1>']
        <inp2> = self.inputs['<input_name_2>']
        <etc>
        # Perform the computation
        < ... >
        # Save the output
        self.outputs['<output_name_1>'] = <computed_value_1>
        self.outputs['<output_name_2>'] = <etc>
\end{lstlisting}


\subsection{batch and realtime execution operations}
\label{sec:advanced}

Some additional work is required to develop custom batch and realtime execution controllers.
etc etc.




